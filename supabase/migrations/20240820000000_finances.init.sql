
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

CREATE SCHEMA IF NOT EXISTS "finances";

ALTER SCHEMA "finances" OWNER TO "postgres";

CREATE SCHEMA IF NOT EXISTS "public";

ALTER SCHEMA "public" OWNER TO "pg_database_owner";

COMMENT ON SCHEMA "public" IS 'standard public schema';

CREATE OR REPLACE FUNCTION "finances"."log_last_accessed_page"("page" bigint) RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Insert or update the last accessed page
    INSERT INTO finances.last_accessed_pages (user_id, page_id, last_accessed)
    VALUES (auth.uid(), page, now())
    ON CONFLICT (user_id, page_id) DO UPDATE
    SET last_accessed = EXCLUDED.last_accessed;

    -- Delete the oldest accessed page if more than 5 pages exist for this user
    DELETE FROM finances.last_accessed_pages
    WHERE user_id = auth.uid()
    AND page_id NOT IN (
        SELECT page_id
        FROM finances.last_accessed_pages
        WHERE user_id = auth.uid()
        ORDER BY last_accessed DESC
        LIMIT 5
    );
END;
$$;

ALTER FUNCTION "finances"."log_last_accessed_page"("page" bigint) OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "finances"."book" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" "text" NOT NULL,
    "archived" boolean DEFAULT false,
    "created_by" "uuid" DEFAULT "auth"."uid"() NOT NULL,
    "last_viewed" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE "finances"."book" OWNER TO "postgres";

COMMENT ON TABLE "finances"."book" IS 'Highest group level of expenses';

ALTER TABLE "finances"."book" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "finances"."book_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "finances"."expense" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "date" "date" NOT NULL,
    "amount" real NOT NULL,
    "comment" "text",
    "page_id" bigint NOT NULL,
    "created_by" "uuid" DEFAULT "auth"."uid"() NOT NULL
);

ALTER TABLE "finances"."expense" OWNER TO "postgres";

COMMENT ON TABLE "finances"."expense" IS 'Expense/Income entry';

CREATE OR REPLACE VIEW "finances"."date_sorted_expenses" AS
 SELECT "expense"."id",
    "expense"."created_at",
    "expense"."date",
    "expense"."amount",
    "expense"."comment",
    "expense"."page_id",
    "expense"."created_by"
   FROM "finances"."expense"
  ORDER BY "expense"."date";

ALTER TABLE "finances"."date_sorted_expenses" OWNER TO "postgres";

ALTER TABLE "finances"."expense" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "finances"."expense_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "finances"."expenses_tags" (
    "tag_id" bigint NOT NULL,
    "expense_id" bigint NOT NULL
);

ALTER TABLE "finances"."expenses_tags" OWNER TO "postgres";

COMMENT ON TABLE "finances"."expenses_tags" IS 'Each expense can have 0:n tags linked to it';

CREATE TABLE IF NOT EXISTS "finances"."last_accessed_pages" (
    "user_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
    "page_id" bigint NOT NULL,
    "last_accessed" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE "finances"."last_accessed_pages" OWNER TO "postgres";

COMMENT ON TABLE "finances"."last_accessed_pages" IS 'Last accessed pages by the user';

CREATE TABLE IF NOT EXISTS "finances"."page" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" "text" NOT NULL,
    "book_id" bigint NOT NULL,
    "created_by" "uuid" DEFAULT "auth"."uid"() NOT NULL
);

ALTER TABLE "finances"."page" OWNER TO "postgres";

COMMENT ON TABLE "finances"."page" IS 'List of expenses within a group';

ALTER TABLE "finances"."page" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "finances"."page_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "finances"."pinned_pages" (
    "user_id" "uuid" DEFAULT "auth"."uid"() NOT NULL,
    "page_id" bigint NOT NULL,
    "last_clicked" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE "finances"."pinned_pages" OWNER TO "postgres";

COMMENT ON TABLE "finances"."pinned_pages" IS 'User pinned pages';

COMMENT ON COLUMN "finances"."pinned_pages"."last_clicked" IS 'When was this pinned page last clicked';

CREATE TABLE IF NOT EXISTS "finances"."tag" (
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "color" "text" NOT NULL,
    "name" "text" NOT NULL,
    "id" bigint NOT NULL,
    "book_id" bigint NOT NULL
);

ALTER TABLE "finances"."tag" OWNER TO "postgres";

COMMENT ON TABLE "finances"."tag" IS 'Tags that can be added to each expense, as well as being used to filter the analytics.';

ALTER TABLE "finances"."tag" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "finances"."tag_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "finances"."user_books" (
    "is_admin" boolean DEFAULT true NOT NULL,
    "user_id" "uuid" NOT NULL,
    "book_id" bigint NOT NULL
);

ALTER TABLE "finances"."user_books" OWNER TO "postgres";

COMMENT ON TABLE "finances"."user_books" IS 'Books can be shared with different users';

CREATE TABLE IF NOT EXISTS "public"."user_data" (
    "id" "uuid" NOT NULL,
    "first_name" character varying NOT NULL,
    "last_name" character varying
);

ALTER TABLE "public"."user_data" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_data" IS 'Information to store about the user';

ALTER TABLE ONLY "finances"."book"
    ADD CONSTRAINT "book_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "finances"."expense"
    ADD CONSTRAINT "expense_id_key" UNIQUE ("id");

ALTER TABLE ONLY "finances"."expense"
    ADD CONSTRAINT "expense_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "finances"."expenses_tags"
    ADD CONSTRAINT "expenses_tags_pkey" PRIMARY KEY ("tag_id", "expense_id");

ALTER TABLE ONLY "finances"."last_accessed_pages"
    ADD CONSTRAINT "last_accessed_pages_pkey" PRIMARY KEY ("user_id", "page_id");

ALTER TABLE ONLY "finances"."page"
    ADD CONSTRAINT "page_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "finances"."pinned_pages"
    ADD CONSTRAINT "pinned_pages_pkey" PRIMARY KEY ("user_id", "page_id");

ALTER TABLE ONLY "finances"."tag"
    ADD CONSTRAINT "tag_id_key" UNIQUE ("id");

ALTER TABLE ONLY "finances"."tag"
    ADD CONSTRAINT "tag_pkey" PRIMARY KEY ("name", "id", "book_id");

ALTER TABLE ONLY "finances"."last_accessed_pages"
    ADD CONSTRAINT "unique_page_per_usser" UNIQUE ("page_id", "user_id");

ALTER TABLE ONLY "finances"."user_books"
    ADD CONSTRAINT "user_books_pkey" PRIMARY KEY ("user_id", "book_id");

ALTER TABLE ONLY "finances"."user_books"
    ADD CONSTRAINT "user_books_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."user_data"
    ADD CONSTRAINT "user_data_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "finances"."book"
    ADD CONSTRAINT "book_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."expense"
    ADD CONSTRAINT "expense_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON UPDATE CASCADE ON DELETE SET NULL;

ALTER TABLE ONLY "finances"."expense"
    ADD CONSTRAINT "expense_page_id_fkey" FOREIGN KEY ("page_id") REFERENCES "finances"."page"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."expenses_tags"
    ADD CONSTRAINT "expenses_tags_expense_id_fkey" FOREIGN KEY ("expense_id") REFERENCES "finances"."expense"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."expenses_tags"
    ADD CONSTRAINT "expenses_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "finances"."tag"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."last_accessed_pages"
    ADD CONSTRAINT "last_accessed_pages_page_id_fkey" FOREIGN KEY ("page_id") REFERENCES "finances"."page"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."last_accessed_pages"
    ADD CONSTRAINT "last_accessed_pages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."page"
    ADD CONSTRAINT "page_book_id_fkey" FOREIGN KEY ("book_id") REFERENCES "finances"."book"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."page"
    ADD CONSTRAINT "page_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."pinned_pages"
    ADD CONSTRAINT "pinned_pages_page_id_fkey" FOREIGN KEY ("page_id") REFERENCES "finances"."page"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."pinned_pages"
    ADD CONSTRAINT "pinned_pages_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."tag"
    ADD CONSTRAINT "tag_book_id_fkey" FOREIGN KEY ("book_id") REFERENCES "finances"."book"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."user_books"
    ADD CONSTRAINT "user_books_book_id_fkey" FOREIGN KEY ("book_id") REFERENCES "finances"."book"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "finances"."user_books"
    ADD CONSTRAINT "user_books_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_data"
    ADD CONSTRAINT "user_data_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id");

CREATE POLICY "Enable delete for users based on user_id" ON "finances"."last_accessed_pages" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));

CREATE POLICY "Enable delete for users based on user_id" ON "finances"."pinned_pages" TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));

ALTER TABLE "finances"."book" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "enable_insert" ON "finances"."book" FOR INSERT TO "authenticated" WITH CHECK (true);

ALTER TABLE "finances"."expense" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "finances"."expenses_tags" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "finances"."last_accessed_pages" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "finances"."page" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "finances"."pinned_pages" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "select_expenses" ON "finances"."expense" USING ((EXISTS ( SELECT 1
   FROM (("finances"."page"
     JOIN "finances"."book" ON (("page"."book_id" = "book"."id")))
     LEFT JOIN "finances"."user_books" ON (("book"."id" = "user_books"."book_id")))
  WHERE (("expense"."page_id" = "page"."id") AND (("book"."created_by" = "auth"."uid"()) OR ("user_books"."user_id" = "auth"."uid"()))))));

CREATE POLICY "select_expenses_tags" ON "finances"."expenses_tags" USING ((EXISTS ( SELECT 1
   FROM ((("finances"."expense"
     JOIN "finances"."page" ON (("expense"."page_id" = "page"."id")))
     JOIN "finances"."book" ON (("page"."book_id" = "book"."id")))
     LEFT JOIN "finances"."user_books" ON (("book"."id" = "user_books"."book_id")))
  WHERE (("expenses_tags"."expense_id" = "expense"."id") AND (("book"."created_by" = "auth"."uid"()) OR ("user_books"."user_id" = "auth"."uid"()))))));

CREATE POLICY "select_tags" ON "finances"."tag" USING ((EXISTS ( SELECT 1
   FROM ("finances"."book"
     LEFT JOIN "finances"."user_books" ON (("book"."id" = "user_books"."book_id")))
  WHERE (("tag"."book_id" = "book"."id") AND (("book"."created_by" = "auth"."uid"()) OR ("user_books"."user_id" = "auth"."uid"()))))));

ALTER TABLE "finances"."tag" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "user_access_books" ON "finances"."book" FOR SELECT USING ((("created_by" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "finances"."user_books"
  WHERE (("user_books"."book_id" = "book"."id") AND ("user_books"."user_id" = "auth"."uid"()))))));

CREATE POLICY "user_access_pages" ON "finances"."page" USING ((EXISTS ( SELECT 1
   FROM ("finances"."book"
     LEFT JOIN "finances"."user_books" ON (("book"."id" = "user_books"."book_id")))
  WHERE (("page"."book_id" = "book"."id") AND (("book"."created_by" = "auth"."uid"()) OR ("user_books"."user_id" = "auth"."uid"())))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM ("finances"."book"
     LEFT JOIN "finances"."user_books" ON (("book"."id" = "user_books"."book_id")))
  WHERE (("page"."book_id" = "book"."id") AND (("book"."created_by" = "auth"."uid"()) OR ("user_books"."user_id" = "auth"."uid"()))))));

ALTER TABLE "finances"."user_books" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow user to acces their data" ON "public"."user_data" TO "authenticated" USING (("id" = "auth"."uid"()));

ALTER TABLE "public"."user_data" ENABLE ROW LEVEL SECURITY;

GRANT USAGE ON SCHEMA "finances" TO "anon";
GRANT USAGE ON SCHEMA "finances" TO "authenticated";
GRANT USAGE ON SCHEMA "finances" TO "service_role";

GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON FUNCTION "finances"."log_last_accessed_page"("page" bigint) TO "anon";
GRANT ALL ON FUNCTION "finances"."log_last_accessed_page"("page" bigint) TO "authenticated";
GRANT ALL ON FUNCTION "finances"."log_last_accessed_page"("page" bigint) TO "service_role";

GRANT ALL ON TABLE "finances"."book" TO "anon";
GRANT ALL ON TABLE "finances"."book" TO "authenticated";
GRANT ALL ON TABLE "finances"."book" TO "service_role";

GRANT ALL ON SEQUENCE "finances"."book_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "finances"."book_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "finances"."book_id_seq" TO "service_role";

GRANT ALL ON TABLE "finances"."expense" TO "anon";
GRANT ALL ON TABLE "finances"."expense" TO "authenticated";
GRANT ALL ON TABLE "finances"."expense" TO "service_role";

GRANT ALL ON TABLE "finances"."date_sorted_expenses" TO "anon";
GRANT ALL ON TABLE "finances"."date_sorted_expenses" TO "authenticated";
GRANT ALL ON TABLE "finances"."date_sorted_expenses" TO "service_role";

GRANT ALL ON SEQUENCE "finances"."expense_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "finances"."expense_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "finances"."expense_id_seq" TO "service_role";

GRANT ALL ON TABLE "finances"."expenses_tags" TO "anon";
GRANT ALL ON TABLE "finances"."expenses_tags" TO "authenticated";
GRANT ALL ON TABLE "finances"."expenses_tags" TO "service_role";

GRANT ALL ON TABLE "finances"."last_accessed_pages" TO "anon";
GRANT ALL ON TABLE "finances"."last_accessed_pages" TO "authenticated";
GRANT ALL ON TABLE "finances"."last_accessed_pages" TO "service_role";

GRANT ALL ON TABLE "finances"."page" TO "anon";
GRANT ALL ON TABLE "finances"."page" TO "authenticated";
GRANT ALL ON TABLE "finances"."page" TO "service_role";

GRANT ALL ON SEQUENCE "finances"."page_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "finances"."page_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "finances"."page_id_seq" TO "service_role";

GRANT ALL ON TABLE "finances"."pinned_pages" TO "anon";
GRANT ALL ON TABLE "finances"."pinned_pages" TO "authenticated";
GRANT ALL ON TABLE "finances"."pinned_pages" TO "service_role";

GRANT ALL ON TABLE "finances"."tag" TO "anon";
GRANT ALL ON TABLE "finances"."tag" TO "authenticated";
GRANT ALL ON TABLE "finances"."tag" TO "service_role";

GRANT ALL ON SEQUENCE "finances"."tag_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "finances"."tag_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "finances"."tag_id_seq" TO "service_role";

GRANT ALL ON TABLE "finances"."user_books" TO "anon";
GRANT ALL ON TABLE "finances"."user_books" TO "authenticated";
GRANT ALL ON TABLE "finances"."user_books" TO "service_role";

GRANT ALL ON TABLE "public"."user_data" TO "anon";
GRANT ALL ON TABLE "public"."user_data" TO "authenticated";
GRANT ALL ON TABLE "public"."user_data" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "finances" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "finances" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "finances" GRANT ALL ON SEQUENCES  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "finances" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "finances" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "finances" GRANT ALL ON FUNCTIONS  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "finances" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "finances" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "finances" GRANT ALL ON TABLES  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";

RESET ALL;
